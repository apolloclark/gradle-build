plugins {
  // https://bmuschko.github.io/gradle-docker-plugin
  // https://github.com/bmuschko/gradle-docker-plugin/releases
  id 'com.bmuschko.docker-remote-api' version '4.9.0'
  
  // http://jruby-gradle.org/base
  // https://github.com/jruby-gradle/jruby-gradle-plugin/releases
  id "com.github.jruby-gradle.base" version "1.7.0"
  
  // https://plugins.gradle.org/plugin/com.dorongold.task-tree
  id "com.dorongold.task-tree" version "1.4"
}

// Import task types
import com.bmuschko.gradle.docker.tasks.*
import com.bmuschko.gradle.docker.tasks.image.*
import com.bmuschko.gradle.docker.tasks.container.*
import com.github.jrubygradle.JRubyExec

allprojects {
    apply plugin: 'com.bmuschko.docker-remote-api'
    apply plugin: "com.github.jruby-gradle.base"

    dependencies {
        // https://github.com/mizzy/serverspec/releases
        jrubyExec group: 'rubygems', name: 'serverspec', version: '2.41.4'

        // https://github.com/swipely/docker-api/releases
        jrubyExec group: 'rubygems', name: 'docker-api', version: '1.34.2'
    }
}



// ext.docker_username = "apolloclark"
ext.package_name    = System.properties['package_name']
ext.package_version = System.properties['package_version']
ext.docker_username = System.properties['docker_username']
ext.docker_email    = System.properties['docker_email']
ext.base_image      = "default"
ext.image_name      = "default"
ext.build_date      = new Date().format("yyyyMMdd", TimeZone.getTimeZone('UTC'))
ext.packer_filename = "default"
ext.packer_args = []



// create dynamic reusable code
subprojects {
    // enable the use of sub-project variables
    afterEvaluate { Project project ->
        docker {
            registryCredentials {
                url      = 'https://index.docker.io/v1/'
                username = "$project.docker_username"
                email    = "$project.docker_email"
                password = System.getenv('DOCKER_PASS')
            }
        }
        ext {
            packer_args = []
        }
        task('info', type: GradleBuild) {
            tasks = ['whoami', 'path', 'docker', 'dockerVersion', 'ansiblePlaybook', 'ansiblePlaybookVersion']
        }
        task('whoami', type: Exec) {
            commandLine 'whoami'
        }
        task('path', type: Exec) {
            def command = 'echo $PATH'
            executable "bash" args "-l", "-c", command
            ignoreExitValue = true
        }
        task('docker', type: Exec) {
            def command = 'command -v docker'
            executable "bash" args "-l", "-c", command
            ignoreExitValue = true
        }
        task('dockerVersion', type: Exec) {
            def command = 'docker --version'
            executable "bash" args "-l", "-c", command
            ignoreExitValue = true
        }
        task('ansiblePlaybook', type: Exec) {
            def command = 'command -v ansible-playbook'
            executable "bash" args "-l", "-c", command
            ignoreExitValue = true
        }
        task('ansiblePlaybookVersion', type: Exec) {
            def command = 'ansible-playbook --version'
            executable "bash" args "-l", "-c", command
            ignoreExitValue = true
        }
        task('dockerInfo', type: DockerListImages){
        }



        task('clean') {
            description = 'Clean any previously built images and containers.'

            dependsOn 'cleanImage'
            dependsOn 'cleanImageDate'
            dependsOn 'cleanContainer'
            dependsOn 'cleanManifest'
        }
        task('cleanImage', type: DockerRemoveImage) {
            description = 'Clean any previously built images.'

            targetImageId "$docker_username/$package_name:$package_version-${project.image_name}"
            force = true
            onError { exception ->
                if (!exception.message.contains('No such image'))
                    throw exception
            }
        }
        task('cleanImageDate', type: DockerRemoveImage) {
            description = 'Clean any previously built images, by build date.'
            inputs.property "build_date", "$project.build_date"
            inputs.property "package_version", "$project.package_version"

            targetImageId "$docker_username/$package_name:$package_version-${project.image_name}-$build_date"
            force = true
            onError { exception ->
                if (!exception.message.contains('No such image'))
                    throw exception
            }
        }
        task('cleanContainer', type: DockerRemoveContainer) {
            description = 'Clean any previously built containers.'
            inputs.property "build_date", "$project.build_date"
            inputs.property "package_version", "$project.package_version"

            targetContainerId "$package_name-${project.image_name}"
            force = true
            removeVolumes = true
            onError { exception ->
                if (!exception.message.contains('No such container'))
                    throw exception
            }
        }
        task('cleanManifest'){
            project.file('../../manifest.json').newWriter()
            outputs.files file("../../manifest.json")
        }



        task('buildAnsible') {
            description = 'Build, using Ansible to provision.'
            dependsOn 'buildConfigAnsible'
            dependsOn 'buildDocker'
        }
        task('buildBash') {
            description = 'Build, using Bash to provision.'
            dependsOn 'buildConfigBash'
            dependsOn 'buildDocker'
        }
        task('buildConfigBase') {
            description = 'Set the shared parameters used by Packer.'
            project.packer_args = [
              '-var', "build_date=$build_date",
              '-var', "base_image=$base_image",
              '-var', "image_name=$image_name",
              '-var', "docker_username=$docker_username",
              '-var', "package_name=$package_name",
              '-var', "package_version=$package_version",
              '-var', "ansible_host=$package_name-$package_version-$image_name-$build_date"
            ]
        }
        task('buildConfigAnsible') {
            dependsOn 'buildConfigBase'
            doLast{    
                packer_filename = 'packer_docker_var_ansible.json'
                project.packer_args.add(packer_filename)
                println 'called buildConfigAnsible()'
            }
        }
        task('buildConfigBash') {
            dependsOn 'buildConfigBase'
            doLast{
                packer_filename = 'packer_docker_var_bash.json'
                project.packer_args.add(packer_filename)
                println 'called buildConfigBash()'
            }
        }
        // https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html
        task('validatePackerDocker') {
            description = 'Validate the Packer file, for Docker.'
            inputs.files fileTree(dir: "../../",
                includes: ['**/packer/*.json', '**/scripts/*', '**/files/*', '**/ansible/*.yml'])
            doLast {
                exec {
                    workingDir = '../packer-build'
                    executable = 'packer'
                    def packer_args_local = project.packer_args.clone()
                    packer_args_local.add(0, 'validate')
                    args = packer_args_local
                }
            }
        }
        // https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html
        task('buildDocker') {
            description = 'Build the Docker image.'
            dependsOn 'validatePackerDocker'
            doLast {
                exec {
                    workingDir = '../packer-build'
                    executable = 'packer'
                    def packer_args_local = project.packer_args.clone()
                    packer_args_local.addAll(0, ['build', '-force'])
                    args = packer_args_local
                }
            }
            outputs.file "manifest.json"
        }



        // http://jruby-gradle.org/base/#tasks
        // https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html
        task('testAnsible') {
            description = 'Test, using a Packer Ansible build.'
            dependsOn 'buildAnsible'
            dependsOn 'testServerspec'
        }
        task('testBash') {
            description = 'Test, using a Packer Bash build.'
            dependsOn 'buildBash'
            dependsOn 'testServerspec'
        }
        task('testServerspec', type: JRubyExec) {
            description = 'Test the Docker image, using Serverspec.'
            inputs.files fileTree(dir: "../../spec", includes: ['**/.rb'])

            setEnvironment System.getenv()
            environment DOCKER_USERNAME : "$docker_username"
            environment PACKAGE_NAME    : "$package_name"
            environment PACKAGE_VERSION : "$package_version"
            environment IMAGE_NAME      : "${project.image_name}"

            workingDir '../../spec/'
            script "rspec"
            scriptArgs "Dockerfile_${project.image_name}.rb"
        }



        task('pushAnsble') {
            description = 'Clean any previously built images and containers.'

            dependsOn 'testAnsible'
            dependsOn 'pushImage'
            dependsOn 'pushImageDate'
        }
        task('pushBash'){
            dependsOn 'testBash'
            dependsOn 'pushImage'
            dependsOn 'pushImageDate'
        }
        task('pushImage', type: DockerPushImage) {
            description = 'Push a Docker image.'
            imageName = "$docker_username/$package_name"
            tag = "$package_version-${project.image_name}"

        }
        task('pushImageDate', type: DockerPushImage) {
            description = 'Clean any previously built images.'
            imageName = "$docker_username/$package_name"
            tag = "$package_version-${project.image_name}-$build_date"
        }
    }
}